{"version":3,"file":"opencage-api.min.js","sources":["webpack://opencage/webpack/runtime/define_property_getters","webpack://opencage/webpack/runtime/has_own_property","webpack://opencage/webpack/runtime/make_namespace_object","webpack://opencage/./src/errors/GeocodeError.ts","webpack://opencage/./src/fetch.ts","webpack://opencage/./src/helpers/geocodeHelpers.ts","webpack://opencage/./src/geocode.ts"],"sourcesContent":["__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n        if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n            Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n        }\n    }\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","/**\n * GeocodeError type\n *\n * Represents the Error Type\n */\nexport type GeocodeErrorStatus = {\n  /**\n   * The HTTP status code\n   */\n  code: number;\n  /**\n   * The error message\n   */\n  message: string;\n};\n\n/**\n * GeocodeError class\n *\n * Represents the Error Object\n */\nexport class GeocodeError extends Error {\n  /**\n   * The response error object or the status error object for backward compatibility\n   */\n  response?: Response | { status: GeocodeErrorStatus };\n  /**\n   * The status error object\n   */\n  status?: GeocodeErrorStatus;\n  /**\n   * Constructor for the GeocodeError class\n   *\n   * @param message the error message\n   */\n  constructor(message: string) {\n    super(message);\n    this.name = 'GeocodeError';\n  }\n}\n","import { GeocodeError } from './errors/GeocodeError';\nimport { version } from './version';\n\nconst USER_AGENT = `OpenCageData Geocoding NodeJS API Client/${version}`;\n\n/**\n * @private\n * @description checks the response status and throws an error if the status is not ok\n * @param response {Response} the response object\n * @returns {Response} the response object\n * @throws {GeocodeError} the error object\n */\nexport function checkFetchStatus(response: Response) {\n  if (response.status >= 200 && response.status < 300) {\n    return response;\n  }\n  // console.debug('request failed with status', response.status);\n  // console.debug('request failed with status text', response.statusText);\n  const message = response.statusText || `HTTP error ${response.status}`;\n  const error = new GeocodeError(message);\n  error.status = {\n    code: response.status,\n    message,\n  };\n  error.response = response;\n  throw error;\n}\n\nexport function parseJSON(response: Response) {\n  return response.json();\n}\n\n/**\n * fetches the url and returns a promise\n * @param  {String}  url     the url to fetch\n * @param  {Function} resolve the resolve function\n * @param  {Function} reject  the reject function\n */\nexport async function fetchUrl(\n  url: string,\n  resolve: any,\n  reject: any,\n  signal?: AbortSignal\n) {\n  fetch(url, {\n    method: 'GET',\n    headers: {\n      'User-Agent': USER_AGENT,\n      'Content-Type': 'application/json',\n      Accept: 'application/json',\n    },\n    signal,\n  })\n    .then(checkFetchStatus)\n    .then(parseJSON)\n    .then((data) => {\n      // console.debug('request succeeded with JSON response', data);\n      resolve(data);\n    })\n    .catch((error) => {\n      // console.debug('request failed', { error });\n      reject(error);\n    });\n}\n","import { GeocodingRequest } from '../types/GeocodingRequest';\nimport { GeocodeError, GeocodeErrorStatus } from '../errors/GeocodeError';\nimport { GeocodingOptions } from '../types/GeocodingOptions';\n\nconst OPENCAGEDATA_JSON_URL = 'https://api.opencagedata.com/geocode/v1/json';\n\n/**\n * @private\n * @description Returns a {GeocodeError} object with status (validation error)\n * @param code {number} HTTP status code\n * @param message {string} error message\n * @returns {GeocodeError}\n *\n */\nexport function buildValidationError(code: number, message: string) {\n  const error = new GeocodeError(message);\n  const status: GeocodeErrorStatus = {\n    code,\n    message,\n  };\n  error.status = status;\n  error.response = { status };\n  return error;\n}\n\n/**\n * @private\n * returns true is `param` is not defined or empty\n * @param  {String}  param object property as a string\n * @return {Boolean}       returns value\n */\nexport function isUndefinedOrEmpty(param: string | null | undefined): boolean {\n  return typeof param === 'undefined' || param === '';\n}\n\n/**\n * @private\n * returns true is `param` is not defined or null\n * @param  {String}  param object property as a string\n * @return {Boolean}       returns value\n */\nexport function isUndefinedOrNull(\n  param: GeocodingRequest | null | undefined\n): boolean {\n  return typeof param === 'undefined' || param === null;\n}\n\n/**\n * @private\n *\n * @param input\n * @returns the request query string\n */\nexport function buildQueryString(input: any): string {\n  if (isUndefinedOrNull(input)) {\n    return '';\n  }\n  return Object.keys(input)\n    .map(\n      (key) =>\n        `${encodeURIComponent(key)}=${encodeURIComponent(input[key] || '')}`\n    )\n    .join('&');\n}\n\n/**\n * @private\n * Builds the query params including key and proxy URL\n *\n * @param {GeocodingRequest} input\n * @param {GeocodingOptions} options\n * @returns {Object}  {\n *   missingKey: boolean,\n *   endpoint: string,\n *   query: GeocodingRequest copy of the input object with the proxyURL removed\n * }\n */\nexport function buildQuery(\n  input: GeocodingRequest,\n  options?: GeocodingOptions\n) {\n  const query = { ...input };\n  let endpoint = OPENCAGEDATA_JSON_URL;\n  let missingKey = false;\n  if (\n    !isUndefinedOrEmpty(input.proxyURL) ||\n    !isUndefinedOrEmpty(options?.proxyURL)\n  ) {\n    endpoint = options?.proxyURL as string;\n    if (isUndefinedOrEmpty(endpoint)) {\n      endpoint = input.proxyURL as string;\n    }\n    delete query.proxyURL;\n  } else {\n    if (isUndefinedOrEmpty(input.key) && typeof process !== 'undefined') {\n      query.key = process.env.OPENCAGE_API_KEY;\n    }\n    if (isUndefinedOrEmpty(query.key)) {\n      missingKey = true;\n    }\n  }\n  return {\n    missingKey,\n    endpoint,\n    query,\n  };\n}\n","import type { GeocodingRequest } from './types/GeocodingRequest';\nimport type { GeocodingResponse } from './types/GeocodingResponse';\nimport type { GeocodingOptions } from './types/GeocodingOptions';\nimport { fetchUrl } from './fetch';\nimport {\n  buildValidationError,\n  isUndefinedOrNull,\n  buildQueryString,\n  buildQuery,\n} from './helpers/geocodeHelpers';\n\nconst MISSING_OR_BAD_QUERY = 'missing or bad query';\nconst MISSING_API_KEY = 'missing API key';\n\n/**\n * geocode address and reverse geocode coordinates using\n * [OpenCage API](https://opencagedata.com/api) requesting the json format.\n *\n * @param  {GeocodingRequest} input the input query parameter as JSON object,\n *  the attribute `q` is required, the `key` can be omitted when using\n *  a `proxyURL`, and when using node with a dedicated environment variable\n *  (OPENCAGE_API_KEY).\n *  Others optional parameters can be found at OpenCage Data API\n *  [documentation](https://opencagedata.com/api#forward-opt)\n *\n * @param  {Object} options the options object,\n *  the attribute `signal` is used to abort the request when the signal is aborted.\n *  the attribute `proxyURL` is used to proxy the request to a different URL.\n *\n * @return {Promise<GeocodingResponse>} a promise resolved by the json format API payload\n */\nexport async function geocode(\n  input: GeocodingRequest,\n  options?: GeocodingOptions\n): Promise<GeocodingResponse> {\n  return new Promise((resolve, reject) => {\n    if (isUndefinedOrNull(input)) {\n      const error = buildValidationError(400, MISSING_OR_BAD_QUERY);\n      reject(error);\n      return;\n    }\n    const params = buildQuery(input, options);\n    if (params.missingKey) {\n      const error = buildValidationError(401, MISSING_API_KEY);\n      reject(error);\n      return;\n    }\n    const { query, endpoint } = params;\n    const qs = buildQueryString(query);\n    const url = `${endpoint}?${qs}`;\n    // console.debug(url);\n    fetchUrl(url, resolve, reject, options?.signal);\n  });\n}\n"],"names":["Object","e","Symbol","GeocodeError","Error","message","checkFetchStatus","response","error","parseJSON","fetchUrl","url","resolve","reject","signal","fetch","data","buildValidationError","code","status","isUndefinedOrEmpty","param","geocode","input","options","Promise","params","buildQuery","query","endpoint","missingKey","process","qs","key","encodeURIComponent"],"mappings":"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"}